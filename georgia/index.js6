// this page's HTML template with the [hash] cache-buster
// and the only stylesheet
require('./index.scss');
require('./index.src.html');

// shared constants between pages: the list of years, the red-blue color gradient, ...
import { PLAN_YEARS } from "./../_common/constants";
import { STATE_NAME_TO_CODE } from "./../_common/constants";
import { CONUS_BOUNDS } from "./../_common/constants";
import { STATE_BOUNDING_BOXES } from "./../_common/constants";
import { WASTEDVOTE_CHART_WASTED_D } from "./../_common/constants";
import { WASTEDVOTE_CHART_WASTED_R } from "./../_common/constants";
import { WASTEDVOTE_CHART_USEFUL_D } from "./../_common/constants";
import { WASTEDVOTE_CHART_USEFUL_R } from "./../_common/constants";
import { lookupBias } from "./../_common/functions";
import { drawBiasBellChart } from "./../_common/functions";

// bundle polyfills and local/vendor libraries specific to this page
require('core-js/fn/object/values');
require('core-js/fn/object/entries');
require('./../_common/jslibs/leaflet-control-zoombar.js');
require('./../_common/jslibs/leaflet-control-zoombar.css');
require('./../_common/jslibs/leaflet-control-partylegend.js');
require('./../_common/jslibs/leaflet-control-partylegend.css');
require('./../_common/jslibs/leaflet-polygon.fillPattern.js');


//
// CONSTANTS
//

// the currently-visible state: boundary type + year, e.g. US House districts for 1984
// these are affected by window.selectXXX() family of functions which ultimately are all wrappers over loadDataForSelectedBoundaryAndYear()
const CURRENT_VIEW = {
    // year: '2000',  // four-digit year (string)
    // boundtype: 'ushouse',  // short polygon name: ushouse statehouse statesenate
    // planorelection: 'election',  // show 'election' or 'plan' statistics on right-hand side
    // metric: 'eg', // which metric tab is showing?
};

// what fields to use for Election Mode and Plan Mode
// each record contains bias-related statistics for both that specific election-year and the average of all years the plan was implemented
// e.g. mmd and mmd_avg, eg_percentrank and eg_avg_percentrank
// the various sub-systems from updateStatsFromCsvContent() will need to load "the bias field" based on whether CURRENT_VIEW.planorelection indicates that we want a Election Year or a Plan Overview
// example:   fetch the bias score from either 'the election field' or 'the plan field' as necessary
//            const relevantbiasfield = ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].bias;
//            const bias_score        = thisyeardata[relevantbiasfield];
// not all fields are listed here, just the ones which vary between election view and plan view
const ELECTION_PLAN_RECORD_FIELDS = {
    'election': {
        // NOTE per issue 94, the 6 per-election fields (eg, bias, mm + rank) are stripped from CSVs to make them more compact downloads, until we reinstate election-year displays
        'eg': 'eg_adj',
        'egrank': 'eg_percentrank',
        'bias': 'bias',
        'biasrank': 'bias_percentrank',
        'mm': 'mmd',
        'mmrank': 'mmd_percentrank',
        'wasted_dem': 'wasted_dem',
        'wasted_rep': 'wasted_rep',
        'votes_dem': 'votes_dem',
        'votes_rep': 'votes_rep',
        'votes_both': 'votes_twop',
        'seats': 'seats',
        'seats_dem': 'seats_dem',
        'seats_rep': 'seats_r',
    },
    'plan': {
        'eg': 'eg_adj_avg',
        'egrank': 'eg_avg_percentrank',
        'bias': 'bias_avg',
        'biasrank': 'bias_avg_percentrank',
        'mm': 'mmd_avg',
        'mmrank': 'mmd_avg_percentrank',
        'wasted_rep': 'wasted_rep_plan',
        'wasted_dem': 'wasted_dem_plan',
        'votes_dem': 'votes_dem_plan',
        'votes_rep': 'votes_rep_plan',
        'votes_both': 'votes_twop_plan',
        'seats': 'seats_plan',
        'seats_dem': 'seats_dem_plan',
        'seats_rep': 'seats_r_plan',
    },
};

// the bounding box of this state
const STATE_BBOX = STATE_BOUNDING_BOXES[STATE_NAME_TO_CODE[SELECTED_STATE]];

// for the map of election winnders & plan winners, the styles
const MAP_DISTRICT_STYLE_DEFAULT = {
    stroke: true, color: '#999999', weight: 1,
    fill: true, fillColor: '#cccccc', fillOpacity: 0.6,
    bubblingMouseEvents: false,
    clickable: false,
};
const MAP_DISTRICT_STYLE_MIXED = {
    stroke: true, color: '#cccccc', weight: 1,
    fill: "url(/images/mapfill_nodata.png)", fillColor: 'transparent', fillOpacity: 0.6,  // crosshatch image fill, thanks to leaflet-polygon.fillPattern.js
    bubblingMouseEvents: false,
    clickable: false,
};
const MAP_DISTRICT_STYLE_DEMOCRAT = {
    stroke: true, color: '#cccccc', weight: 1,
    fill: true, fillColor: '#0049A8', fillOpacity: 0.6,
    bubblingMouseEvents: false,
    clickable: false,
};
const MAP_DISTRICT_STYLE_REPUBLICAN = {
    stroke: true, color: '#cccccc', weight: 1,
    fill: true, fillColor: '#C71C36', fillOpacity: 0.6,
    bubblingMouseEvents: false,
    clickable: false,
};


//
// PAGE STARTUP / INIT FUNCTIONS
//

$(document).ready(function () {
    // see also SELECTED_STATE declaration hardcoded into HTML template

    initYearPickers();
    initBoundaryPicker();
    initMap();
    initMetricTabTracking();
    initLoadStartingConditions();  // this will implicitly call loadDataForSelectedBoundaryAndYear() after setup, loading the map

    $(window).on('resize', handleResize);
    handleResize();
});

window.handleResize = () => {
    // various things that don't gracefully handle being resized, so we need to help them out
};

window.initMap = () => {
    // the map of the state, in its initial state with no data
    // basemap + labels with some hacks on the pane-and-zindex of the labels
    // simple zoom+home control
    // see also updateMapForCurrentSelection() which updates the map to the given election/plan/year

    window.MAP = L.map('map', {
        minZoom: 4,
        maxZoom: 11,
        zoomControl: false,
        scrollWheelZoom: false,
    }).fitBounds(STATE_BBOX);

    L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_nolabels/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="http://cartodb.com/attributions">CartoDB</a>',
        subdomains: 'abcd',
    }).addTo(MAP);
    L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/toner-labels/{z}/{x}/{y}{r}.png', {
        attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, under <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="http://openstreetmap.org">OpenStreetMap</a>, under <a href="http://www.openstreetmap.org/copyright">ODbL</a>.',
        subdomains: 'abcd',
        pane: 'markerPane',
    }).addTo(MAP);

    new L.Control.ZoomBar({
        position: 'topright',
        homeBounds: STATE_BBOX,
    }).addTo(MAP);

    new L.Control.PartyLegend({
        position: 'topleft',
    }).addTo(MAP);

    // more prep work: create L.TopoJSON which parses both GeoJSON and TopoJSON
    L.TopoJSON = L.GeoJSON.extend({
        addData: function(jsonData) {
            if (jsonData.type === "Topology") {
                for (var key in jsonData.objects) {
                    const geojson = topojson.feature(jsonData, jsonData.objects[key]);
                    L.GeoJSON.prototype.addData.call(this, geojson);
                }
            }    
            else {
                L.GeoJSON.prototype.addData.call(this, jsonData);
            }
        }
    });
};

window.initYearPickers = () => {
    // mobile
    // two separate UIs for cycling through prev/next election year or district plan
    // only one is visible and that's based on whether our URL (or defaults) indicate that we want to see a year/plan
    // see initLoadStartingConditions() for that startup logic to show only one
    // see selectElectionOrPlan() which does the real work when prev/next are performed
    const $plan_picker = $('#yearpicker-small > div[data-picker="plan"]');
    const $year_picker = $('#yearpicker-small > div[data-picker="election"]');
    const $year_listing = $year_picker.find('div.readout');
    const $plan_listing = $plan_picker.find('div.readout');

    PLAN_YEARS.forEach((year) => {
        $(`<span data-year="${year}">${year} Election</span>`).appendTo($year_listing).hide();
    });

    $year_picker.on('click', 'div.nextprev.right', function () {
        const $targetbutton = $year_listing.find('span:visible').next('span');
        const year = $targetbutton.attr('data-year');
        if (! year) return;  // don't allow clicking past the first/last
        selectElectionOrPlan(year, 'election');
    });
    $year_picker.on('click', 'div.nextprev.left', function () {
        const $targetbutton = $year_listing.find('span:visible').prev('span');
        const year = $targetbutton.attr('data-year');
        if (! year) return;  // don't allow clicking past the first/last
        selectElectionOrPlan(year, 'election');
    });

    // there won't be any plans listed here at startup; see redrawYearPicker() since the list of plans depends on district type
    $plan_picker.on('click', 'div.nextprev.right', function () {
        const $targetbutton = $plan_listing.find('span:visible').next('span');
        const year = $targetbutton.attr('data-year');
        selectElectionOrPlan(year, 'plan');
    });
    $plan_picker.on('click', 'div.nextprev.left', function () {
        const $targetbutton = $plan_listing.find('span:visible').prev('span');
        const year = $targetbutton.attr('data-year');
        selectElectionOrPlan(year, 'plan');
    });

    // desktop
    // the list of "year beads" running down the side, which is two columns for election years (right) and district plans (left)
    // see also redrawYearPicker() which assigns the data-plan="" attribute to plans, and shows/hides election years
    // both bases on the actual data present
    const $picker_big   = $('#yearpicker-big');
    const $plansdiv     = $('<div class="plans col-xs-5"></div>').appendTo($picker_big);
    const $electionsdiv = $('<div class="elections col-xs-7"></div>').appendTo($picker_big);
    
    $('<span>Election<br>Years</span>').appendTo($electionsdiv);
    $('<span>Enacted<br>Plans</span>').appendTo($plansdiv);

    PLAN_YEARS.slice().reverse().forEach((year) => {
        $(`<a data-year="${year}" title="Show details for the ${year} election year"><span></span> ${year}</a>`).appendTo($electionsdiv);
        $(`<a data-year="${year}" title="Show details for this districting plan"><span></span></a>`).appendTo($plansdiv);  // will be tagged with data-plan attribute when we have data
    });

    $electionsdiv.on('click', 'a', function () {
        const year = $(this).attr('data-year');
        // issue 94: for the time being, years also go to Plans not election-year details
        //selectElectionOrPlan(year, 'election');
        selectElectionOrPlan(year, 'plan');
    });

    $plansdiv.on('click', 'a', function () {
        const year = $(this).attr('data-year');
        selectElectionOrPlan(year, 'plan');
    });
};

window.initBoundaryPicker = () => {
    $('#boundarypicker div[data-boundary]').click(function () {
        const boundarytype = $(this).attr('data-boundary');
        selectBoundaryType(boundarytype);
    });
};

window.initMetricTabTracking = () => {
    // when they switch metrics tabs, log a Google Analytics event
    $('#tabs-metrics a[data-toggle="tab"]').on('shown.bs.tab', function (e) {
        const whichtab = $(e.target).prop('href').replace(/.+#tab-/, '');  // the suffix is the metric name, e.g. #tab-efficiencygap
        logMetricToggleToGoogleAnalytics(whichtab);
    });

    // when metric tab is switched, also track that in the CURRENT_VIEW; see also selectMetric() which may be relevant
    $('#tabs-metrics a[data-toggle="tab"]').on('shown.bs.tab', function (e, p, q) {
        const whichmetric = $(e.target).attr('data-metric');  // the suffix is the metric name, e.g. #tab-efficiencygap
        CURRENT_VIEW.metric = whichmetric;
        updateUrlHash();
    });
};

window.initLoadStartingConditions = () => {
    // analyze the #!year-polytype hash to see what year + district we should load
    // see alsoupdateUrlHash() which generates this hash

    const params   = window.location.hash.replace(/^#!/, '').split('-');
    const year     = params.shift() || PLAN_YEARS[PLAN_YEARS.length - 1];
    const planyear = params.shift() || 'plan';
    const district = params.shift() || 'ushouse';
    const metric   = params.shift() || 'eg';

    // toggle which yearpicker-small is displayed
    // per issue 129 only one of these is visible and that depends on whether the page loads with a plan/election
    $('#yearpicker-small > div').hide().filter(`[data-picker="${planyear}"]`).show();

    // ready, set, go
    selectMetric(metric);
    selectElectionOrPlan(year, planyear);
    selectBoundaryType(district);
};


//
// RUNTIME FUNCTIONS FOR CHANGING YEAR + DISTRICT TYPE
// loadDataForSelectedBoundaryAndYear() is the real worker here; the others are basically convenience functions
//

window.loadDataForSelectedBoundaryAndYear = () => {
    if (! CURRENT_VIEW.year || ! CURRENT_VIEW.boundtype) return;  // need both; during startup one will be blank, so avoid an error

    // fetch the CSV file and then use the callbacks to update the map
    const url = `/data/bias_${CURRENT_VIEW.boundtype}.csv`;
    Papa.parse(url, {
        download: true,
        header: true,
        complete: function (results) {
            // district type was implicitly "filtered" by which CSV was fetched; now filter by this state
            const alldataforthisstate = results.data.filter((row) => {
                return row.state == STATE_NAME_TO_CODE[SELECTED_STATE];
            });

            // data fixes
            results.data.forEach((row) => {
                // cast fields to integer
                [
                    'eg_adj', 'eg_adj_avg', 'eg_avg_percentrank', 'eg_percentrank',
                    'bias', 'bias_avg','bias_avg_percentrank', 'bias_percentrank',
                    'mmd', 'mmd_avg', 'mmd_avg_percentrank', 'mmd_percentrank',
                ].forEach((fieldname) => { row[fieldname] = parseFloat(row[fieldname]); });

                // cast fields to integer
                [
                    'votes_twop_plan', 'votes_twop', 'votes_dem_plan',  'votes_dem',
                    'wasted_dem_plan', 'wasted_dem',
                    'wasted_rep_plan', 'wasted_rep',
                    'seats_plan',  'seats',
                    'seats_dem_plan',  'seats_dem',
                    'seats_r_plan', 'seats_r',
                ].forEach((fieldname) => { row[fieldname] = parseInt(row[fieldname]); });

                // create the votes_rep and votes_rep_plan
                row.votes_rep_plan = row.votes_twop_plan - row.votes_dem_plan;
                row.votes_rep      = row.votes_twop - row.votes_dem;
            });

            // data fixes: go through the CSV and add a plan_minyear and plan_maxyear attribute
            // this is the min and max year in which that year's "plan" was in effect
            {
                // pass 1: 
                let plans_analyzed = {};
                results.data.forEach((row) => {
                    if (! plans_analyzed[row.plan]) {
                        // not seen this year before; assume this is the first and last year of this newly-found plan
                        plans_analyzed[row.plan] = { minyear: row.year, maxyear: row.year };
                    }
                    else {
                        // we've seen this plan, update the min and max if appropriate
                        if (row.year < plans_analyzed[row.plan].minyear) plans_analyzed[row.plan].minyear = row.year;
                        if (row.year > plans_analyzed[row.plan].maxyear) plans_analyzed[row.plan].maxyear = row.year;
                    }
                });

                // pass 2: go through the rows and update from the plans_analyzed
                results.data.forEach((row) => {
                    row.plan_minyear = plans_analyzed[row.plan].minyear;
                    row.plan_maxyear = plans_analyzed[row.plan].maxyear;
                });
            }

            // ready, set, go!
            updateStatsFromCsvContent(alldataforthisstate);

            // log the GA request
            logRequestToGoogleAnalytics();
        },
        error: function () {
            // an error, meaning bad network or missing CSV
            // treat this the same as receiving 0 rows, so the UI states that it has no data
            updateStatsFromCsvContent([]);
        },
    });

    // update URL params to show the current search
    updateUrlHash();
};

window.logRequestToGoogleAnalytics = () => {
    if (! gtag) return;  // no Google Tag Manager = don't bother; this should be declared along with GTM

    gtag('event', 'statedetails', {
        name: STATE_NAME_TO_CODE[SELECTED_STATE],
        value: CURRENT_VIEW.year,
        event_category: CURRENT_VIEW.planorelection,
        event_label : CURRENT_VIEW.boundtype,
    });
};

window.updateUrlHash = () => {
    // update URL params to show the current search
    // see also initLoadStartingConditions() which will load such a state
    const hash = `#!${CURRENT_VIEW.year}-${CURRENT_VIEW.planorelection}-${CURRENT_VIEW.boundtype}-${CURRENT_VIEW.metric}`;
    window.location.replace(hash);
};

window.selectMetric = (whichmetric) => {
    // click the metric tab for them, and save to the state
    // see also initMetricTabTracking() which is perhaps relevant to these tabs being clicked
    $(`#tabs-metrics a[data-metric="${whichmetric}"]`).click();
    CURRENT_VIEW.metric = whichmetric;
    updateUrlHash();
};

window.selectElectionOrPlan = (year, planorelection) => {
    // not supplied = fill it in
    if (! planorelection) planorelection = CURRENT_VIEW.planorelection;

    // UI update: highlight this button or select this option
    $('#yearpicker-small').val(`${year}-${planorelection}`);

    // go through the election years (right side) and plan spans (left side)
    // and tag them to indicate what we're highlighting: this election year, or this districting plan
    const $elinks = $('#yearpicker-big div.elections a').removeClass('active');
    //const $plinks = $('#yearpicker-big div.plans a').removeClass('active');
    if (planorelection == 'election') {
        $elinks.filter(`[data-year="${year}"]`).addClass('active');
    }
    else {
        // the plans timeline is redrawn by loadDataForSelectedBoundaryAndYear() since it depends on what was selected
    }

    // save to the state and refresh the map + data
    CURRENT_VIEW.year = year;
    CURRENT_VIEW.planorelection = planorelection;
    loadDataForSelectedBoundaryAndYear();
};

window.selectBoundaryType = (boundtype) => {
    // UI update: highlight this button
    $('#boundarypicker div').removeClass('active').filter(`[data-boundary="${boundtype}"]`).addClass('active');

    // save to the state and refresh the map + data
    CURRENT_VIEW.boundtype = boundtype;
    loadDataForSelectedBoundaryAndYear();
};

window.updateStatsFromCsvContent = (allcsvdata) => {
    // handle a condition of no data at all for this whole district type, for any year
    if (allcsvdata.length) {
        $('#maincontent span[data-hasdata-atall]').hide().filter('[data-hasdata-atall="true"]').show();
        $('#sidebar span[data-hasdata-atall]').hide().filter('[data-hasdata-atall="true"]').show();
    }
    else {
        $('#maincontent span[data-hasdata-atall]').hide().filter('[data-hasdata-atall="false"]').show();
        $('#sidebar span[data-hasdata-atall]').hide().filter('[data-hasdata-atall="false"]').show();
        return;  // nothing else we can do until they select a district type with data
    }

    // okay so we have SOME data for this state + district type
    // how many distinct plans and years are listed for this district type?
    const distinct_years = {};
    const distinct_plans = {};
    allcsvdata.forEach((row) => {
        distinct_years[row.year] = true;
        distinct_plans[row.plan] = true;
    });
    $('span[data-metric="electioncount"]').text(Object.keys(distinct_years).length.toLocaleString());
    $('span[data-metric="plancount"]').text(Object.keys(distinct_plans).length.toLocaleString());

    // okay so we have SOME data for this state + district type
    // redraw the large yearpicker, indicating years in which a new plan was implemented
    redrawYearPicker(allcsvdata);

    // final check: do we have data for this district for the selected year?
    // if not, fill in the closest year for which we DO have data
    // which actually does involve peeking at most of the state so we can link to it
    const thisyeardata = allcsvdata.filter((row) => { return row.year == CURRENT_VIEW.year; })[0];
    if (thisyeardata) {
        $('#maincontent span[data-hasdata-thisyear]').hide().filter('[data-hasdata-thisyear="true"]').show();
    }
    else {
        $('#maincontent span[data-hasdata-thisyear]').hide().filter('[data-hasdata-thisyear="false"]').show();

        const wehavetheseyears = allcsvdata.map((row) => {
            return parseInt(row.year);
        });
        wehavetheseyears.sort((p, q) => {
            const px = Math.abs(p - parseInt(CURRENT_VIEW.year));
            const qx = Math.abs(q - parseInt(CURRENT_VIEW.year));
            return (px != qx) ? (px > qx ? 1 : -1) : (p > q ? -1 : 1); // order by diff from desired year; or else by higher-year if equal spread
        });
        const closestyear = wehavetheseyears[0];

        const $link = $('#maincontent span[data-hasdata-thisyear="false"] a');
        $link.attr('data-year', closestyear);
        $link.find('span[data-field="closestyear"]').text(closestyear);

        return;  // nothing else we can do until they select a year which has data
    }

    //
    // from here on out we know that we're showing a specific election/plan
    // and we have a lot of little things to fill in
    // we hand off to functions since it's rather a lot of lines to read as one giant block
    //

    // set the title
    updateMetricsTitle(thisyeardata);

    // a single sentence summarizing the 3 metric outcomes: 2 out of 3, they all agree, no consistency found, ...
    updateMetricsSummary(thisyeardata);

    // update the metric tabs: various sentences in each tab, and the tabs themselves
    updateMetricsTabs(thisyeardata);

    // refresh some charts: Efficiency Gap Wasted Votes, Partisan Bias Seat Share
    updateWastedVotesChart(thisyeardata);
    updateSeatShareChart(thisyeardata);

    // the bell charts indicating this plan's relative bias rating for each metric
    drawBiasBellCharts(thisyeardata);

    // update the map, showing the election outcomes / plan winners
    updateMapForCurrentSelection(thisyeardata);
};

window.updateMetricsTitle = (yeardata) => {
    const minyear = yeardata.plan_minyear;
    const maxyear = yeardata.plan_maxyear;
    const year    = yeardata.year;

    // compose a title for what we're seeing
    let title = `${minyear}-${maxyear} Redistricting Plan`;
    if (minyear == maxyear) {
        title = `${maxyear} Redistricting Plan`;  // don't say "2000-2000 plan"
    }
    if (CURRENT_VIEW.planorelection == 'election') {
        title = `${year} Election`;
    }

    // apply it
    $('#maincontent span[data-field="title"]').text(title);
};

window.updateMetricsSummary = (yeardata) => {
    // compose a sentence summarizing how many metrics indicate a skew one way or the other
    // e.g. "2 out of 3 metrics agree..." or "all metrics agree..."
    const eg_score  = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].eg ];
    const pb_score  = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].bias ];
    const mm_score  = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].mm ];

    // how many metrics favor D or R beyond threshold?
    const favor_party_eg = lookupBias('eg', eg_score);
    const favor_party_pb = lookupBias('pb', pb_score);
    const favor_party_mm = lookupBias('mm', mm_score);
    const metrics_favor_d = [ favor_party_eg, favor_party_pb, favor_party_mm ].filter((biasinfo) => { return biasinfo.isbiased && biasinfo.partycode == 'd'; }).length;
    const metrics_favor_r = [ favor_party_eg, favor_party_pb, favor_party_mm ].filter((biasinfo) => { return biasinfo.isbiased && biasinfo.partycode == 'r'; }).length;

    // compose the sentence, with 2 out of 3 being the minimum worth mentioning
    let biasstatement = "The metrics do not consistently indicate a skew in either partyâ€™s favor.";
    if      (metrics_favor_d == 3) biasstatement = "All three metrics indicate a pro-Democrat skew.";
    else if (metrics_favor_r == 3) biasstatement = "All three metrics indicate a pro-Republican skew.";
    else if (metrics_favor_d == 2 && metrics_favor_r == 0) biasstatement = "Two of the three metrics indicate a pro-Democrat skew.";
    else if (metrics_favor_r == 2 && metrics_favor_d == 0) biasstatement = "Two of the three metrics indicate a pro-Republican skew.";

    // fill it in
    $('#maincontent span[data-metric="biasstatement"]').text(biasstatement);
};

window.updateMetricsTabs = (yeardata) => {
    // fetch the seat counts, vote counts, bias metric scores, ... depending on whether we are showing a Plan or Election
    const eg_score    = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].eg ];
    const pb_score    = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].bias ];
    const mm_score    = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].mm ];
    const eg_rank     = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].egrank ];
    const bias_rank   = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].biasrank ];
    const mmd_rank    = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].mmrank ];
    const seats_rep   = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].seats_rep ];
    const seats_dem   = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].seats_dem ];
    const totalseats  = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].seats ];

    // for the selected year/plan
    // the 3 plan-bias metrics: do any of them show a bias toward D or R?
    // tag the biasicon icons in the metrics' tabs
    const biaseval_eg    = lookupBias('eg', eg_score);
    const favor_party_eg = biaseval_eg.party;
    const loser_party_eg = biaseval_eg.otherparty;
    const favor_code_eg  = biaseval_eg.partycode;
    const loser_code_eg  = biaseval_eg.otherparty;
    const favor_color_eg = biaseval_eg.colorcode;
    const cssclass_eg    = biaseval_eg.cssclass;
    const isbiased_eg    = biaseval_eg.isbiased;
    const hadseats       = favor_party_eg == 'Republican' ? seats_rep : seats_dem;
    const statement_eg   = `${! isbiased_eg ? 'This metric indicates a balanced plan.' : ''} Votes for ${favor_party_eg} candidates were wasted at a rate ${(100 * Math.abs(eg_score)).toFixed(1)}% lower than votes for ${loser_party_eg} candidates.`;
    const biastext_eg    = `${! isbiased_eg ? 'No consistent skew was found in favor of either party.' : ''} This plan is more skewed than ${Math.round(100 * eg_rank)}% of the enacted plans we have analyzed nationwide.`;
    const roundscore_eg  = Math.round(100 * Math.abs(eg_score));  // per issue 170 these ignore the usual balanced-threshold; we want to show even 1% but keep a balanced color

    const biaseval_pb    = lookupBias('pb', pb_score);
    const favor_party_pb = biaseval_pb.party;
    const favor_color_pb = biaseval_pb.color;
    const favor_code_pb  = biaseval_pb.partycode;
    const loser_code_pb  = biaseval_pb.otherparty;
    const cssclass_pb    = biaseval_pb.cssclass;
    const isbiased_pb    = biaseval_pb.isbiased;
    const statement_pb   = `${! isbiased_pb ? 'This metric indicates a balanced plan.' : ''} ${favor_party_pb}s would win ${(100 * Math.abs(pb_score)).toFixed(1)}% extra seats in a hypothetical, perfectly tied election.`;
    const biastext_pb    = `${! isbiased_pb ? 'No consistent skew was found in favor of either party.' : ''} This plan is more skewed than ${Math.round(100 * bias_rank)}% of the enacted plans we have analyzed nationwide.`;
    const roundscore_pb  = Math.round(100 * Math.abs(pb_score));  // per issue 170 these ignore the usual balanced-threshold; we want to show even 1% but keep a balanced color
 
    const biaseval_mm    = lookupBias('mm', mm_score);
    const favor_party_mm = biaseval_mm.party;
    const favor_color_mm = biaseval_mm.color;
    const favor_code_mm  = biaseval_mm.partycode;
    const loser_code_mm  = biaseval_mm.otherparty;
    const cssclass_mm    = biaseval_mm.cssclass;
    const isbiased_mm    = biaseval_mm.isbiased;
    const statement_mm   = `${! isbiased_mm ? 'This metric indicates a balanced plan.' : ''} The median ${favor_party_mm} vote share was ${(100 * Math.abs(mm_score)).toFixed(1)}% higher than the mean ${favor_party_mm} vote share.`;
    const biastext_mm    = `${! isbiased_mm ? 'No consistent skew was found in favor of either party.' : ''} This plan is more skewed than ${Math.round(100 * mmd_rank)}% of the enacted plans we have analyzed nationwide.`;
    const roundscore_mm  = Math.round(100 * Math.abs(mm_score));  // per issue 170 these ignore the usual balanced-threshold; we want to show even 1% but keep a balanced color

    // color the tab-swatches for the three metrics
    {
        let $swatch = $('#maincontent ul.nav-tabs a[href="#tab-efficiencygap"] span.biasicon');
        $swatch.removeClass('republican').removeClass('democratic').text(' ');
        if (isbiased_eg) $swatch.addClass(cssclass_eg).text(favor_code_eg);
    }
    {
        let $swatch = $('#maincontent ul.nav-tabs a[href="#tab-partisanbias"] span.biasicon');
        $swatch.removeClass('republican').removeClass('democratic').text(' ');
        if (isbiased_pb) $swatch.addClass(cssclass_pb).text(favor_code_pb);
    }
    {
        let $swatch = $('#maincontent ul.nav-tabs a[href="#tab-meanmedian"] span.biasicon');
        $swatch.removeClass('republican').removeClass('democratic').text(' ');
        if (isbiased_mm) $swatch.addClass(cssclass_mm).text(favor_code_mm);
    }

    // fill in those +DR% numbers and the summary texts, at the top of the metric tabs
    {
        let metricdrsum_eg   = '0% Balanced';
        if (roundscore_eg) metricdrsum_eg = `+${roundscore_eg}% ${favor_party_eg}`;

        $('#tab-efficiencygap span[data-field="metricdrsum"]').text(metricdrsum_eg);
        $('#tab-efficiencygap span[data-field="metricstatement"]').text(statement_eg);
        $('#tab-efficiencygap span[data-field="plancompare"]').text('This plan is more skewed toward X than 100% all of the enacted plans we have analyzed nationwide.');
        $('#tab-efficiencygap span[data-field="biasstatement"]').text(biastext_eg);
    }
    {
        let metricdrsum_pb   = '0% Balanced';
        if (roundscore_pb) metricdrsum_pb = `+${roundscore_pb}% ${favor_party_pb}`;

        $('#tab-partisanbias span[data-field="metricdrsum"]').text(metricdrsum_pb);
        $('#tab-partisanbias span[data-field="metricstatement"]').text(statement_pb);
        $('#tab-partisanbias span[data-field="plancompare"]').text('This plan is more skewed toward X than 100% all of the enacted plans we have analyzed nationwide.');
        $('#tab-partisanbias span[data-field="biasstatement"]').text(biastext_pb);
    }
    {
        let metricdrsum_mm   = '0% Balanced';
        if (roundscore_mm) metricdrsum_mm = `+${roundscore_mm}% ${favor_party_mm}`;

        $('#tab-meanmedian span[data-field="metricdrsum"]').text(metricdrsum_mm);
        $('#tab-meanmedian span[data-field="metricstatement"]').text(statement_mm);
        $('#tab-meanmedian span[data-field="plancompare"]').text('This plan is more skewed toward X than 100% all of the enacted plans we have analyzed nationwide.');
        $('#tab-meanmedian span[data-field="biasstatement"]').text(biastext_mm);
    }

    // color those +DR% boxes
    {
        const $sumbox = $('#tab-efficiencygap div.metricdrsum').removeClass('republican').removeClass('democratic').removeClass('balanced').addClass(cssclass_eg);
    }
    {
        const $sumbox = $('#tab-partisanbias div.metricdrsum').removeClass('republican').removeClass('democratic').removeClass('balanced').addClass(cssclass_pb);
    }
    {
        const $sumbox = $('#tab-meanmedian div.metricdrsum').removeClass('republican').removeClass('democratic').removeClass('balanced').addClass(cssclass_mm);
    }
};

window.updateSeatShareChart = (yeardata) => {
    const pb_score = 100 * yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].bias ];

    let r_seatshare = 50;
    let d_seatshare = 50;

    if (pb_score < 0) {  // as usual, R is <0
        r_seatshare += Math.abs(pb_score);
        d_seatshare -= Math.abs(pb_score);
    }
    else if (pb_score > 0) {
        r_seatshare -= Math.abs(pb_score);
        d_seatshare += Math.abs(pb_score);
    }

    // construct the chart series
    const votechartdata = [
        {
            name: 'Seat Share',
            data: [ d_seatshare, r_seatshare ],
            colors: [ WASTEDVOTE_CHART_WASTED_D, WASTEDVOTE_CHART_WASTED_R ],
        }
    ];

    // now chart it
    // and show the chart, in case it was previously hidden
    $('#chart-pbseatshare').show();
    Highcharts.chart('chart-pbseatshare', {
        chart: {
            type: 'bar',
        },
        credits: {
            enabled: false,
        },
        title: {
            text: 'Seat Share at 50% of the Vote',
            margin: 0,
        },
        xAxis: {
            categories: ['D', 'R']
        },
        yAxis: {
            min: 0,
            max: 100,
            title: {
                enabled: false,
            },
        },
        legend: {
            enabled: false,
        },
        tooltip: {
            formatter: function () {
                const party = this.point.category == 'D' ? 'Democratic' : 'Republican';
                return `${party}<br/>${this.y.toLocaleString()}% ${this.series.name}`;
            },
        },
        plotOptions: {
            series: {
                stacking: 'normal',
                pointPadding: 0,
                groupPadding: 0,
                pointWidth: 25,
                colorByPoint: true,  // use the custom-assigned colors,
                animation: false,
            }
        },
        series: votechartdata,
    });
};

window.updateWastedVotesChart = (yeardata) => {
    // fetch the vote tallies for this election/plan
    const totalvotes = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].votes_both ];
    const wasted_dem = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].wasted_dem ];
    const wasted_rep = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].wasted_rep ];
    const votes_dem  = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].votes_dem ];
    const votes_rep  = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].votes_rep ];

    // if there is no data on votes + wasted votes for this election/plan
    // then just hide this chart
    if (! totalvotes) {
        $('#chart-egvoteswasted').hide();
        return;
    }

    // construct the chart series
    const votechartdata = [
        {
            name: 'Wasted Votes',
            data: [0, 0],
            colors: [ WASTEDVOTE_CHART_WASTED_D, WASTEDVOTE_CHART_WASTED_R ],
        },
        {
            name: 'Efficient Votes',
            data: [0, 0],
            colors: [ WASTEDVOTE_CHART_USEFUL_D, WASTEDVOTE_CHART_USEFUL_R ],
        }
    ];
    votechartdata[0].data[0] = wasted_dem;
    votechartdata[0].data[1] = wasted_rep;
    votechartdata[1].data[0] = votes_dem - wasted_dem;
    votechartdata[1].data[1] = votes_rep - wasted_rep;

    // now chart it
    // and show the chart, in case it was previously hidden
    $('#chart-egvoteswasted').show();
    Highcharts.chart('chart-egvoteswasted', {
        chart: {
            type: 'bar',
        },
        credits: {
            enabled: false,
        },
        title: {
            text: 'Efficient Votes and Wasted Votes',
            margin:0,
        },
        xAxis: {
            categories: ['D', 'R']
        },
        yAxis: {
            min: 0,
            title: {
                enabled: false,
            },
            tickAmount: 4,
            showFirstLabel: false,
        },
        legend: {
            enabled: false,
        },
        tooltip: {
            formatter: function () {
                const party = this.point.category == 'D' ? 'Democratic' : 'Republican';
                return `${party}<br/>${this.y.toLocaleString()} ${this.series.name}`;
            },
        },
        plotOptions: {
            series: {
                stacking: 'normal',
                pointPadding: 0,
                groupPadding: 0,
                pointWidth: 25,
                colorByPoint: true,  // use the custom-assigned colors,
                animation: false,
            }
        },
        series: votechartdata,
    });
};

window.redrawYearPicker = (csvdata) => {
    // THE BIG/DESKTOP YEARPICKER
    // the big yearpicker has a button to select the given election year
    // but also the left-most dot-and-dash thing indicating when a new plan was enacted
    // while the years are a universal constant, the plan-enactment years depends on what district type we're discussing
    // so must be redrawn here after data are had
    // ALSO needs to handle missing data, hiding missing years but still drawing nice timelines for the years we do have (Alabama statehouse, issue 167)
    {
        // a lookup dict: year => plan
        // a lookup dict: for each plan, its first year
        // a lookup dict: year => EG bias ratings
        const yearplans = {};
        const planfirstyears = {};
        const yearbiases = {};
        csvdata.forEach((row) => {
            yearplans[row.year] = {
                plan: row.plan,
                bias: row.eg_adj_avg,
            };

            planfirstyears[row.plan] = row.plan_minyear;

            yearbiases[row.year] = lookupBias('eg', row.eg_adj_avg);
        });

        // the A links on the plan side & year side
        const $planslinks = $('#yearpicker-big div.plans').find('a');
        const $yearslinks = $('#yearpicker-big div.elections').find('a');

        // go through the year + plan links
        // hide any which have no data
        // tag the plan links with their plan
        $planslinks.each(function () {
            const $thislink = $(this);
            const year      = $thislink.attr('data-year');
            const planinfo  = yearplans[year];

            if (! planinfo) {
                $thislink.attr('data-plan', '').hide();
            }
            else {
                $thislink.attr('data-plan', planinfo.plan).show();
            }
        });
        $yearslinks.each(function () {
            const $thislink = $(this);
            const year      = $thislink.attr('data-year');
            const planinfo  = yearplans[year];

            if (! planinfo) {
                $thislink.attr('data-plan', '').hide();
            }
            else {
                $thislink.attr('data-plan', planinfo.plan).show();
            }
        });

        // now that we have only visible links tagged with plans
        // assign the row with the plan-firstyear as a circle (colored by EG bias that year), and leave others as a dash
        // based on the planfirstyears lookup created earlier
        const default_color = '#4d599e'; // see state_template.scss and $dark-purple-color
        $planslinks.removeClass('plan-begin').addClass('plan-continue').prop('title', 'Show details for this districting plan').find('span').css({ 'background-color': default_color });

        Object.entries(planfirstyears).forEach(([plan, firstyear]) => {
            const $thislink = $planslinks.filter(`[data-plan="${plan}"]`).last();  // last link = first year
            const $circle   = $thislink.find('span');
            const year      = $thislink.attr('data-year');
            const biasinfo  = yearbiases[year];

            $thislink.removeClass('plan-continue').addClass('plan-begin');
            $circle.css({ 'background-color': biasinfo.color });
        });

        // final touch: if we are showing a Plan, then highlight the Plan clickers accordingly
        if (CURRENT_VIEW.planorelection == 'plan') {
            const $plinks = $('#yearpicker-big div.plans a').removeClass('active');
            const plan = $plinks.filter(`[data-year="${CURRENT_VIEW.year}"]`).first().attr('data-plan');
            $plinks.filter(`[data-plan="${plan}"]`).addClass('active');
        }
    }

    // THE SMALL/MOBILE YEARPICKER
    // update the election year readout, showing the selected year
    // as well as the next/prev buttons if we are now st the first/last
    {
        // show this year's readout
        const $picker    = $('#yearpicker-small > div[data-picker="election"]');
        const $yearlinks = $picker.find('> div.readout > span').hide();
        const $thislink  = $yearlinks.filter(`[data-year="${CURRENT_VIEW.year}"]`).show();
        const $prevbutton = $picker.find('div.nextprev.left');
        const $nextbutton = $picker.find('div.nextprev.right');

        // detect first year and disable prev; detect last year and disable next
        if ($thislink.is(':first-child')) $prevbutton.addClass('disabled');
        else                              $prevbutton.removeClass('disabled');
        if ($thislink.is(':last-child'))  $nextbutton.addClass('disabled');
        else                              $nextbutton.removeClass('disabled');
    }

    // now the plan picker: a list of plans, and a data-year= of their starting year
    {

        const plans_known = {};
        csvdata.forEach((row) => {
            if (! plans_known[row.plan]) {
                plans_known[row.plan] = { plan: row.plan, minyear: row.plan_minyear, maxyear: row.plan_maxyear };
            }
        });

        const plans_listing = Object.values(plans_known);
        plans_listing.sort((p,q) => { return p.minyear < q.minyear ? -1 : 1; });

        const $picker = $('#yearpicker-small > div[data-picker="plan"]');

        const $readout = $picker.find('> div.readout').empty();
        plans_listing.forEach((planinfo) => {
            const text = planinfo.minyear == planinfo.maxyear ? `${planinfo.minyear} Plan` : `${planinfo.minyear}-${planinfo.maxyear} Plan`;
            $(`<span data-plan="${planinfo.plan}" data-year="${planinfo.minyear}" data-minyear="${planinfo.minyear}" data-maxyear="${planinfo.maxyear}">${text}</span>`).appendTo($readout).hide();
        });

        // show the selected year  (not easy: we have to find a range of minyear-maxyear, may not be an exact year that is offered)
        // detect first year and disable prev; detect last year and disable next
        const $prevbutton = $picker.find('div.nextprev.left');
        const $nextbutton = $picker.find('div.nextprev.right');

        const $thislink = $readout.find('span').filter(function () {
            const $this = $(this);
            return $this.attr('data-minyear') <= CURRENT_VIEW.year && $this.attr('data-maxyear') >= CURRENT_VIEW.year;
        }).show();

        if ($thislink.is(':first-child')) $prevbutton.addClass('disabled');
        else                              $prevbutton.removeClass('disabled');
        if ($thislink.is(':last-child'))  $nextbutton.addClass('disabled');
        else                              $nextbutton.removeClass('disabled');
    }
};

window.drawBiasBellCharts = (yeardata) => {
    // just a wrapper around drawBiasBellChart as it's mostly identical for all 3 metrics
    const egscore = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].eg ];
    const mmscore = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].mm ];
    const pbscore = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].bias ];

    drawBiasBellChart('eg', egscore, 'metric-bellchart-eg', CURRENT_VIEW.boundtype, CURRENT_VIEW.planorelection);
    drawBiasBellChart('mm', mmscore, 'metric-bellchart-mm', CURRENT_VIEW.boundtype, CURRENT_VIEW.planorelection);
    drawBiasBellChart('pb', pbscore, 'metric-bellchart-pb', CURRENT_VIEW.boundtype, CURRENT_VIEW.planorelection);
};

window.updateMapForCurrentSelection = (yeardata) => {
    const whichplan      = yeardata.plan;
    const whichlevel     = CURRENT_VIEW.boundtype;
    const whichyear      = CURRENT_VIEW.year;
    const planorelection = CURRENT_VIEW.planorelection;
    const geojsonurl     = `/data/districtpolygons/${whichlevel}-${whichplan}.json`;
    const csvurl         = `/data/electionoutcomes_${whichlevel}.csv`;
    const statecode      = yeardata.state;
    // console.log([ 'updateMapForCurrentSelection', yeardata, CURRENT_VIEW.year, CURRENT_VIEW.boundtype, whichplan ]);

    // load the TopoJSON and set it up as the MAP's polygons layer
    // keep a reference to the layer so we can add/remove it
    $.get(geojsonurl, function (jsondata) {
        $('#map').show();
        MAP.invalidateSize();

        if (MAP.polygondistrictsoverlay) {
            MAP.removeLayer(MAP.polygondistrictsoverlay);
        }

        MAP.polygondistrictsoverlay = new L.TopoJSON(jsondata, {
            style: MAP_DISTRICT_STYLE_DEFAULT,
        }).addTo(MAP);

        applyStylesToMapPolygons();
    }, 'json')
    .fail(function (error) {
        // on error, hide map: we have no geometry for this plan
        $('#map').hide();
    });

    // after loading the polygons, style them by election winner or plan winner
    // that data is in a CSV of all election+plan outcomes, we will filter to state
    // then style polygons by the relevant field
    function applyStylesToMapPolygons() {
        Papa.parse(csvurl, {
            download: true,
            header: true,
            complete: function (results) {
                // filter to year + state, or year + plan
                // filtering down the data in a separate step, makes it a lot easier to isolate the relevant results, separately from the polygon-style code later
                if (planorelection == 'election') {
                    // election year; filter by "year" and the "plan" field starting with this state code
                    results = results.data.filter((row) => {
                        return row.year == whichyear && row.plan.substr(0, 2) == statecode;
                    });
                }
                else {
                    // must be a plan; filter by the "plan" field
                    results = results.data.filter((row) => {
                        return row.plan == whichplan;
                    });
                }
                // console.log([ 'applyStylesToMapPolygons() results are:', results ]);

                // go through the polygons and match their "DISTRICT" property to CSV's "district" field
                // then style them according to winner of that election or plan
                MAP.polygondistrictsoverlay.eachLayer(function (layer) {
                    const district_id = layer.feature.properties.DISTRICT;
                    const csvinfo = results.filter((row) => { return row.district == district_id; })[0];

                    if (! csvinfo) {
                        // this district on the map, has no corresponding entry in the election/plan data
                        layer.setStyle(MAP_DISTRICT_STYLE_DEFAULT);
                    }
                    else if (planorelection == 'election') {
                        // color by election winner
                        switch (csvinfo.winner) {
                            case 'D':
                                layer.setStyle(MAP_DISTRICT_STYLE_DEMOCRAT);
                                break;
                            case 'R':
                                layer.setStyle(MAP_DISTRICT_STYLE_REPUBLICAN);
                                break;
                            default:
                                layer.setStyle(MAP_DISTRICT_STYLE_MIXED);
                                break;
                        }
                    }
                    else {
                        // color by plan winner
                        switch (csvinfo.winner_plan) {
                            case 'D':
                                layer.setStyle(MAP_DISTRICT_STYLE_DEMOCRAT);
                                break;
                            case 'R':
                                layer.setStyle(MAP_DISTRICT_STYLE_REPUBLICAN);
                                break;
                            default:
                                layer.setStyle(MAP_DISTRICT_STYLE_MIXED);
                                break;
                        }
                    }
                });
            }, // end of CSV download
            error: function () {
                // an error, meaning bad network or missing CSV
                // set all polygons to the nodata style
                MAP.polygondistrictsoverlay.eachLayer(function (layer) {
                    layer.setStyle(MAP_DISTRICT_STYLE_DEFAULT);
                });
            },
        });
    }
};

window.logMetricToggleToGoogleAnalytics = (whichmetric) => {
    if (! gtag) return;  // no Google Tag Manager = don't bother; this should be declared along with GTM

    gtag('event', 'metricdetails', {
        value: CURRENT_VIEW.year,
        event_category: whichmetric,
        event_label : `${CURRENT_VIEW.boundtype}-${CURRENT_VIEW.planorelection}`,
    });
};
